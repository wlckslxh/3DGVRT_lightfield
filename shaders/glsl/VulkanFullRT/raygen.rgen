/*
 * Sogang Univ, Graphics Lab, 2024
 * 
 * Abura Soba, 2025
 * 
 * Full Ray Tracing
 *
 * Ray generation shader
 */

#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : require

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

//#include "../base/define.glsl"
#include "../base/light.glsl"
//#include "../base/geometrytypes.glsl"
#include "../base/3dgs.glsl"
#include "../base/utils.glsl"

/*** 3dgrt style ***/
void initializeRayPayload(RayPayload rayPayload){
	for(int i = 0; i < MAX_HIT_PER_TRACE; i++){
		rayPayload.hits[i].particleId = INVALID_PARTICLE_ID;
		rayPayload.hits[i].dist = INFINITE_DISTANCE;
	}
}

/*** playground style ***/
//struct RayData{
//	vec3 radiance;
//	float density;
//	vec3 normal;
//	float hitDistance;
//	float rayLastHitDistance;
//	uint hitCount;
//
//	void initialize(){
//		radiance = vec3(0.0f);
//		density = 0.0f;
//		normal = vec3(0.0f);
//		hitDistance = 0.0f;
//		rayLastHitDistance = 0.0f;
//		hitCount = 0;
//	}
//}

/***** 3DGS *****/
layout(location = 0) rayPayloadEXT RayPayload rayPayload;

// Initialized with default value. Appropriate value will be transfered from application.
layout(constant_id = 0) const uint numOfLights = 1;	
layout(constant_id = 1) const uint numOfDynamicLights = 1;
layout(constant_id = 2) const uint numOfStaticLights = 1;
layout(constant_id = 3) const uint staticLightOffset = 1;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform uniformBuffer
{
	mat4 viewInverse;
	mat4 projInverse;
	Light lights[numOfDynamicLights];
	Param params;
} ubo;
layout(binding = 3, set = 0) uniform uniformBufferStaticLight
{
	Light lights[numOfStaticLights];
} uboStaticLight;

// gas->aabb
//Param params;
#if !BUFFER_REFERENCE
layout(std140, binding = 4, set = 0) buffer ParticleDensities {
	ParticleDensity d[];
} particleDensities;
layout(std430, binding = 5, set = 0) buffer ParticleSphCoefficients {
	float c[];
} particleSphCoefficients;	// [features_albedo(vec3), features_specular(float)]. params.particleRadiance
layout(std430, binding = 6, set = 0) buffer ParticleVisibility {
	float v[];
} particleVisibilities;
#endif

/***** 3DGS Functions *****/
//void traceVolumetricGS(vec3 rayOrigin, vec3 rayDirection, float tmin, float tmax){
//	//check image range (why here?)
//	const vec2 idx = vec2(gl_LaunchIDEXT.xy);
//	if(idx.x > frameBounds.x) || (idx.y > frameBounds.y)){
//		return;
//	}
//}
//
//vec4 traceGaussians(vec3 rayOrigin, vec3 rayDirection, const float tmin, const float tmax){
//	traceVolumetricGS(rayOrigin, rayDirection, tmin, tmax);
//
//	return accumulated_radiance;
//}

void trace(RayPayload rayPayload, vec3 rayOri, vec3 rayDir, const float tmin, const float tmax){
	initializeRayPayload(rayPayload);
	traceRayEXT(topLevelAS, gl_RayFlagsSkipClosestHitShaderEXT, 0xff, 0, 1, 0, rayOri, tmin, rayDir, tmax, 0);
}

// ��ƼŬ�� �ֺ��� �ִ� ���� ����
float particleResponse(float grayDist){
	switch (PARTICLE_KERNEL_DEGREE) {
    case 8: // Zenzizenzizenzic
    {
        float s      = -0.000685871056241f;
        const float grayDistSq = grayDist * grayDist;
        return exp(s * grayDistSq * grayDistSq);
    }
    case 5: // Quintic
    {
        float s = -0.0185185185185f;
        return exp(s * grayDist * grayDist * sqrt(grayDist));
    }
    case 4: // Tesseractic
    {
        float s = -0.0555555555556f;
        return exp(s * grayDist * grayDist);
    }
    case 3: // Cubic
    {
        float s = -0.166666666667f;
        return exp(s * grayDist * sqrt(grayDist));
    }
    case 1: // Laplacian
    {
        float s = -1.5f;
        return exp(s * sqrt(grayDist));
    }
    case 0: // Linear
    {
        /* static const */ float s = -0.329630334487f;
        return max(1.f + s * sqrt(grayDist), 0.f);
    }
    default: // Quadratic
    {
        float s = -0.5f;
        return exp(s * grayDist);
    }
    }
}

#if BUFFER_REFERENCE
void fetchParticleDensity(
	const uint particleIdx,
	const uint64_t densityBufferDeviceAddress,
	out vec3 particlePosition,
	out vec3 particleScale,
	out mat3 particleRotation,
	out float particleDensity){
	const ParticleDensity particleData = Densities[densityBufferDeviceAddress].d[nonuniformEXT(particleIdx)];

	particlePosition = particleData.position;
	particleScale = particleData.scale;
	particleRotation = quaternionWXYZToMatrix(particleData.quaternion);
	particleDensity = particleData.density;
}

void fetchParticleSphCoefficients(
	const uint particleIdx,
	const float sphCoefficientBufferDeviceAddress,
	out vec3 sphCoefficients[]) {
	const uint particleOffset = particleIdx * SPH_MAX_NUM_COEFFS * 3;
	for(unsigned int i = 0; i < SPH_MAX_NUM_COEFFS; i++){
		const int offset = i * 3;
		sphCoefficients[i] = vec3(
			particlesSphCoefficients[particleOffset + offset + 0],
            particlesSphCoefficients[particleOffset + offset + 1],
            particlesSphCoefficients[particleOffset + offset + 2]);
	}
}
#else
void fetchParticleDensity(
	const uint particleIdx,
	out vec3 particlePosition,
	out vec3 particleScale,
	out mat3 particleRotation,
	out float particleDensity){
	const ParticleDensity particleData = particleDensities.d[nonuniformEXT(particleIdx)];

	particlePosition = particleData.position;
	particleScale = particleData.scale;
	particleRotation = quaternionWXYZToMatrix(particleData.quaternion);
	particleDensity = particleData.density;
}

// load spherical harmonics coefficient
void fetchParticleSphCoefficients(
	const uint particleIdx,
	out vec3 sphCoefficients[SPH_MAX_NUM_COEFFS]) {
	const uint particleOffset = particleIdx * SPH_MAX_NUM_COEFFS * 3;	// 3 : RGB
	for(uint i = 0; i < SPH_MAX_NUM_COEFFS; i++){
		uint offset = i * 3;
		sphCoefficients[i] = vec3(
			particleSphCoefficients.c[nonuniformEXT(particleOffset + offset + 0)],
            particleSphCoefficients.c[nonuniformEXT(particleOffset + offset + 1)],
            particleSphCoefficients.c[nonuniformEXT(particleOffset + offset + 2)]);
	}
}
#endif

// calc spherical harmonics with coefficients
// not a special algorithm
// algorithm from spherical harmonics
// "parametric radiance function" in paper
vec3 radianceFromSpH(int deg, const vec3 sphCoefficients[SPH_MAX_NUM_COEFFS], const vec3 rdir, bool clamped){
	vec3 rad = SH_C0 * sphCoefficients[0];
	if(deg > 0){
		const vec3 dir = rdir;

		const float x = dir.x;
		const float y = dir.y;
		const float z = dir.z;
		rad = rad - SH_C1 * y * sphCoefficients[1] + SH_C1 * z * sphCoefficients[2] - SH_C1 * x * sphCoefficients[3];

		if (deg > 1){
			const float xx = x * x, yy = y * y, zz = z * z;
            const float xy = x * y, yz = y * z, xz = x * z;
            rad = rad + SH_C2[0] * xy * sphCoefficients[4] + SH_C2[1] * yz * sphCoefficients[5] +
                  SH_C2[2] * (2.0f * zz - xx - yy) * sphCoefficients[6] +
                  SH_C2[3] * xz * sphCoefficients[7] + SH_C2[4] * (xx - yy) * sphCoefficients[8];
			if (deg > 2) {
                rad = rad + SH_C3[0] * y * (3.0f * xx - yy) * sphCoefficients[9] +
                      SH_C3[1] * xy * z * sphCoefficients[10] +
                      SH_C3[2] * y * (4.0f * zz - xx - yy) * sphCoefficients[11] +
                      SH_C3[3] * z * (2.0f * zz - 3.0f * xx - 3.0f * yy) * sphCoefficients[12] +
                      SH_C3[4] * x * (4.0f * zz - xx - yy) * sphCoefficients[13] +
                      SH_C3[5] * z * (xx - yy) * sphCoefficients[14] +
                      SH_C3[6] * x * (xx - 3.0f * yy) * sphCoefficients[15];
			}
		}
	}
	rad += 0.5f;
	return clamped ? max(rad, vec3(0.0f)) : rad;
}

bool processHit(
	vec3 rayOrigin,
	vec3 rayDirection,
	uint particleIdx,
#if BUFFER_REFERENCE
	const uint64_t densityBufferDeviceAddress,
	const uint64_t sphCoefficientBufferDeviceAddress,
#endif
	float minParticleKernelDensity,
	float minParticleAlpha,
	int sphEvalDegree,
	inout float transmittance,
	inout vec3 radiance,
	inout float depth
#if ENABLE_NORMALS
	,inout vec3 normal
#endif
	){
	vec3 particlePosition;
	vec3 particleScale;
	mat3 particleRotation;
	float particleDensity;
	
	fetchParticleDensity(
        particleIdx,
#if BUFFER_REFERENCE
        densityBufferDeviceAddress,
#endif
        particlePosition,
        particleScale,
        particleRotation,
        particleDensity);

	const vec3 giscl   = vec3(1 / particleScale.x, 1 / particleScale.y, 1 / particleScale.z);
    const vec3 gposc   = (rayOrigin - particlePosition);
    const vec3 gposcr  = (gposc * particleRotation);
    const vec3 gro     = giscl * gposcr;
    const vec3 rayDirR = rayDirection * particleRotation;
    const vec3 grdu    = giscl * rayDirR;
    const vec3 grd     = safe_normalize(grdu);

	const vec3 gcrod = SURFEL_PRIMITIVE ? gro + grd * -gro.z / grd.z : cross(grd, gro);
	const float grayDist = dot(gcrod, gcrod);

	const float gres = particleResponse(grayDist);
	const float galpha = min(0.99f, gres * particleDensity);

	const bool acceptHit = (gres > minParticleKernelDensity) && (galpha > minParticleAlpha);
	if (acceptHit) {
        const float weight = galpha * (transmittance);

		const vec3 grds = particleScale * grd * (SURFEL_PRIMITIVE ? -gro.z / grd.z : dot(grd, -1 * gro));
		const float hitT = sqrt(dot(grds, grds));

		vec3 sphCoefficients[SPH_MAX_NUM_COEFFS];
		fetchParticleSphCoefficients(
			particleIdx,
#if BUFFER_REFERENCE
			sphCoefficientBufferDeviceAddress,
#endif
			sphCoefficients);
		const vec3 grad = radianceFromSpH(sphEvalDegree, sphCoefficients, rayDirection, true);

		radiance += grad * weight;
		transmittance *= (1 - galpha);
		depth += hitT * weight;

#if ENABLE_NORMALS
		const float ellispoidSqRadius = 9.0f;
		const vec3 particleScaleRotated = (particleRotation * particleScale);
		normal += weight * (SURFEL_PRIMITIVE ? vec3(0, 0, (grd.z > 0 ? 1 : -1) * particleScaleRotated.z) : safe_normalize((gro + grd * (dot(grd, -1 * gro) - sqrt(ellispoidSqRadius - grayDist))) * particleScaleRotated));
#endif
	}

	return acceptHit;
}

void main()
{
	// set ray origin, direction
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);	// pixel position
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);	// pixel position in WdC
	vec2 d = inUV * 2.0 - 1.0;	// pixel position in NDC
	vec4 rayOrigin = ubo.viewInverse[3];
	vec4 target = ubo.projInverse * vec4(d.x, d.y, 1.0f, 1.0f) ;	// (pixel position in EC) / Wc
	vec4 rayDirection = normalize(ubo.viewInverse * vec4(target.xyz, 0.0f));

	/*** 3dgrt style ***/
	vec3 rayRadiance = vec3(0.0f);
	float rayTransmittance = 1.0f;
	float rayHitDistance = 0.0f;

#ifdef ENABLE_NORMALS
	vec3 rayNormal = vec3(0.0f);
#endif
#ifdef ENABLE_HIT_COUNTS
	uint rayHitsCount = 0;
#endif

	vec2 minMaxT = intersectAABB(ubo.params.aabb, rayOrigin.xyz, rayDirection.xyz);
	const float epsT = EPS_T;

	float rayLastHitDistance = max(0.0f, minMaxT.x - epsT);

	while((rayLastHitDistance <= minMaxT.y) && (rayTransmittance > ubo.params.minTransmittance)){
		// Gather k hits
		trace(rayPayload, rayOrigin.xyz, rayDirection.xyz, rayLastHitDistance + epsT, minMaxT.y + epsT);
		if(rayPayload.hits[0].particleId == INVALID_PARTICLE_ID){
			break;
		}

		// Process k hits
		for(int i = 0; i < MAX_HIT_PER_TRACE; i++){
			const RayHit rayHit = rayPayload.hits[i];

			if((rayHit.particleId != INVALID_PARTICLE_ID) && (rayTransmittance > ubo.params.minTransmittance)){
				const bool acceptedHit = processHit(
					rayOrigin.xyz,
					rayDirection.xyz,
					rayHit.particleId,
#if BUFFER_REFERENCE
					ubo.params.densityBufferDeviceAddress,
					ubo.params.sphCoefficientBufferDeviceAddress,
					ubo.params.visibilityBufferDeviceAddress,
#endif
					ubo.params.hitMinGaussianResponse,
					ubo.params.alphaMinThreshold,
					int(ubo.params.sphEvalDegree),
					rayTransmittance,
					rayRadiance,
					rayHitDistance
#if ENABLE_NORMALS
					,rayNormal
#endif
				);

				if(acceptedHit){
					particleVisibilities.v[nonuniformEXT(rayHit.particleId)] = 1.0f;
				}

				rayLastHitDistance = max(rayLastHitDistance, rayHit.dist);

#ifdef ENABLE_HIT_COUNTS
				rayHitsCount += acceptedHit ? 1 : 0;
#endif
			}
		}
	}

   // enough?
   imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(rayRadiance, 1.0f));

	/*** playground style ***/
//	vec4 volumetricRadDns = traceGaussians(rayOrigin, rayDirection, EPS_T, ray_t_max);
}
