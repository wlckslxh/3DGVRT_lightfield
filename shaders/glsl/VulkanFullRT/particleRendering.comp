/*
 * Abura Soba, 2025
 * 
 * Full Ray Tracing
 *
 * Particle Rendering pass
 *
 * Compute shader
 */

#version 460

#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_ray_query : enable

#include "../base/light.glsl"
#include "../base/3dgs.glsl"
#include "../base/utils.glsl"

layout(local_size_x = 1, local_size_y = 1) in;

// Initialized with default value. Appropriate value will be transfered from application.
layout(constant_id = 0) const uint numOfLights = 1;	
layout(constant_id = 1) const uint numOfDynamicLights = 1;
layout(constant_id = 2) const uint numOfStaticLights = 1;
layout(constant_id = 3) const uint staticLightOffset = 1;
layout(constant_id = 4) const uint windowSizeX = 1;
layout(constant_id = 5) const uint windowSizeY = 1;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform uniformBuffer
{
	mat4 viewInverse;
	mat4 projInverse;
	//Light lights[numOfDynamicLights];
} uboDynamic;
layout(binding = 3, set = 0) uniform uniformBufferStatic
{
	Light lights[numOfStaticLights];
	Aabb aabb;
	float minTransmittance;
	float hitMinGaussianResponse;
	uint sphEvalDegree;
} uboStatic;

#if !BUFFER_REFERENCE
layout(std140, binding = 4, set = 0) buffer ParticleDensities {
	ParticleDensity d[];
} particleDensities;
layout(std430, binding = 5, set = 0) buffer ParticleSphCoefficients {
	float c[];
} particleSphCoefficients;	// [features_albedo(vec3), features_specular(float)]. uboStatic.particleRadiance
layout(std430, binding = 6, set = 0) buffer ParticleVisibility {
	float v[];
} particleVisibilities;
#endif

// Global variable
RayPayload rayPayload;

/*** 3dgrt style ***/
void initializeRayPayload(){
	for(int i = 0; i < MAX_HIT_PER_TRACE; i++){
		rayPayload.hits[i].particleId = INVALID_PARTICLE_ID;
		rayPayload.hits[i].dist = INFINITE_DISTANCE;
	}
}

void compareAndSwapHitPayloadValue(inout RayHit hit, int idx) {
    const float dist = rayPayload.hits[idx].dist;
    if (hit.dist < dist) {
        rayPayload.hits[idx].dist = hit.dist;
        const uint id = rayPayload.hits[idx].particleId;
        rayPayload.hits[idx].particleId = hit.particleId;
        hit.dist = dist;
        hit.particleId = id;
    }
}

void trace(rayQueryEXT rayQuery, vec3 rayOri, vec3 rayDir, const float tmin, const float tmax){
	initializeRayPayload();
	rayQueryInitializeEXT(rayQuery, topLevelAS, gl_RayFlagsNoneEXT, 0xFF, rayOri, tmin, rayDir, tmax);

	while (rayQueryProceedEXT(rayQuery)) {
		if (rayQueryGetIntersectionTypeEXT(rayQuery, false) == gl_RayQueryCandidateIntersectionTriangleEXT) {
			uint primitiveId = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, false);
			float hitT = rayQueryGetIntersectionTEXT(rayQuery, false);
			RayHit hit = RayHit(primitiveId / 20, hitT);

			if(hit.dist < rayPayload.hits[MAX_HIT_PER_TRACE - 1].dist) {
				compareAndSwapHitPayloadValue(hit, 0);
				compareAndSwapHitPayloadValue(hit, 1);
				compareAndSwapHitPayloadValue(hit, 2);
				compareAndSwapHitPayloadValue(hit, 3);
				compareAndSwapHitPayloadValue(hit, 4);
				compareAndSwapHitPayloadValue(hit, 5);
				compareAndSwapHitPayloadValue(hit, 6);
				compareAndSwapHitPayloadValue(hit, 7);
				compareAndSwapHitPayloadValue(hit, 8);
				compareAndSwapHitPayloadValue(hit, 9);
				compareAndSwapHitPayloadValue(hit, 10);
				compareAndSwapHitPayloadValue(hit, 11);
				compareAndSwapHitPayloadValue(hit, 12);
				compareAndSwapHitPayloadValue(hit, 13);
				compareAndSwapHitPayloadValue(hit, 14);
				compareAndSwapHitPayloadValue(hit, 15);

				if(rayPayload.hits[MAX_HIT_PER_TRACE - 1].dist <= hitT) {
					rayQueryConfirmIntersectionEXT(rayQuery);
				}
			}
		}
	}
}

float particleResponse(float grayDist){
	switch (PARTICLE_KERNEL_DEGREE) {
    case 8: // Zenzizenzizenzic
    {
        float s      = -0.000685871056241f;
        const float grayDistSq = grayDist * grayDist;
        return exp(s * grayDistSq * grayDistSq);
    }
    case 5: // Quintic
    {
        float s = -0.0185185185185f;
        return exp(s * grayDist * grayDist * sqrt(grayDist));
    }
    case 4: // Tesseractic
    {
        float s = -0.0555555555556f;
        return exp(s * grayDist * grayDist);
    }
    case 3: // Cubic
    {
        float s = -0.166666666667f;
        return exp(s * grayDist * sqrt(grayDist));
    }
    case 1: // Laplacian
    {
        float s = -1.5f;
        return exp(s * sqrt(grayDist));
    }
    case 0: // Linear
    {
        /* static const */ float s = -0.329630334487f;
        return max(1.f + s * sqrt(grayDist), 0.f);
    }
    default: // Quadratic
    {
        float s = -0.5f;
        return exp(s * grayDist);
    }
    }
}

#if BUFFER_REFERENCE
void fetchParticleDensity(
	const uint particleIdx,
	const uint64_t densityBufferDeviceAddress,
	out vec3 particlePosition,
	out vec3 particleScale,
	out mat3 particleRotation,
	out float particleDensity){
	const ParticleDensity particleData = Densities[nonuniformEXT(densityBufferDeviceAddress)].d[nonuniformEXT(particleIdx)];

	particlePosition = particleData.position;
	particleScale = particleData.scale;
	particleRotation = quaternionWXYZToMatrix(particleData.quaternion);
	particleDensity = particleData.density;
}

void fetchParticleSphCoefficients(
	const uint particleIdx,
	//const float sphCoefficientBufferDeviceAddress,
	out vec3 sphCoefficients[]) {
	const uint particleOffset = particleIdx * SPH_MAX_NUM_COEFFS * 3;
	for(unsigned int i = 0; i < SPH_MAX_NUM_COEFFS; i++){
		const int offset = i * 3;
		sphCoefficients[i] = vec3(
			particlesSphCoefficients[nonuniformEXT(particleOffset + offset + 0)],
            particlesSphCoefficients[nonuniformEXT(particleOffset + offset + 1)],
            particlesSphCoefficients[nonuniformEXT(particleOffset + offset + 2]);
	}
}
#else
void fetchParticleDensity(
	const uint particleIdx,
	out vec3 particlePosition,
	out vec3 particleScale,
	out mat3 particleRotation,
	out float particleDensity){
	const ParticleDensity particleData = particleDensities.d[nonuniformEXT(particleIdx)];

	particlePosition = particleData.position;
	particleScale = particleData.scale;
	particleRotation = quaternionWXYZToMatrix(particleData.quaternion);
	particleDensity = particleData.density;
}

// load spherical harmonics coefficient
void fetchParticleSphCoefficients(
	const uint particleIdx,
	out vec3 sphCoefficients[SPH_MAX_NUM_COEFFS]) {
	const uint particleOffset = particleIdx * SPH_MAX_NUM_COEFFS * 3;	// each has 3 elements
	for(uint i = 0; i < SPH_MAX_NUM_COEFFS; i++){
		uint offset = i * 3;	// each has 3 elements
		sphCoefficients[i] = vec3(
			particleSphCoefficients.c[nonuniformEXT(particleOffset + offset + 0)],
            particleSphCoefficients.c[nonuniformEXT(particleOffset + offset + 1)],
            particleSphCoefficients.c[nonuniformEXT(particleOffset + offset + 2)]);
	}
}
#endif

// calc spherical harmonics with coefficients
// not a special algorithm
// algorithm from spherical harmonics
// "parametric radiance function" in paper
vec3 radianceFromSpH(uint deg, const vec3 sphCoefficients[SPH_MAX_NUM_COEFFS], const vec3 rdir, bool clamped){
	vec3 rad = SH_C0 * sphCoefficients[0];
	if(deg > 0){
		const vec3 dir = rdir;

		const float x = dir.x;
		const float y = dir.y;
		const float z = dir.z;
		rad = rad - SH_C1 * y * sphCoefficients[1] + SH_C1 * z * sphCoefficients[2] - SH_C1 * x * sphCoefficients[3];

		if (deg > 1){
			const float xx = x * x, yy = y * y, zz = z * z;
            const float xy = x * y, yz = y * z, xz = x * z;
            rad = rad + SH_C2[0] * xy * sphCoefficients[4] + SH_C2[1] * yz * sphCoefficients[5] +
                  SH_C2[2] * (2.0f * zz - xx - yy) * sphCoefficients[6] +
                  SH_C2[3] * xz * sphCoefficients[7] + SH_C2[4] * (xx - yy) * sphCoefficients[8];
			if (deg > 2) {
                rad = rad + SH_C3[0] * y * (3.0f * xx - yy) * sphCoefficients[9] +
                      SH_C3[1] * xy * z * sphCoefficients[10] +
                      SH_C3[2] * y * (4.0f * zz - xx - yy) * sphCoefficients[11] +
                      SH_C3[3] * z * (2.0f * zz - 3.0f * xx - 3.0f * yy) * sphCoefficients[12] +
                      SH_C3[4] * x * (4.0f * zz - xx - yy) * sphCoefficients[13] +
                      SH_C3[5] * z * (xx - yy) * sphCoefficients[14] +
                      SH_C3[6] * x * (xx - 3.0f * yy) * sphCoefficients[15];
			}
		}
	}
	rad += 0.5f;
	return clamped ? max(rad, vec3(0.0f)) : rad;
}

bool processHit(
	vec3 rayOrigin,
	vec3 rayDirection,
	uint particleIdx,
#if BUFFER_REFERENCE
	const uint64_t densityBufferDeviceAddress,
	const uint64_t sphCoefficientBufferDeviceAddress,
#endif
	float minParticleKernelDensity,
	float minParticleAlpha,
	uint sphEvalDegree,
	inout float transmittance,
	inout vec3 radiance,
	inout float depth
#if ENABLE_NORMALS
	,inout vec3 normal
#endif
	){
	vec3 particlePosition;
	vec3 particleScale;
	mat3 particleRotation;
	float particleDensity;
	
	fetchParticleDensity(
        particleIdx,
#if BUFFER_REFERENCE
        densityBufferDeviceAddress,
#endif
        particlePosition,
        particleScale,
        particleRotation,
        particleDensity);

	const vec3 giscl   = vec3(1 / particleScale.x, 1 / particleScale.y, 1 / particleScale.z);
    const vec3 gposc   = (rayOrigin - particlePosition);
    const vec3 gposcr  = (gposc * particleRotation);
    const vec3 gro     = giscl * gposcr;
    const vec3 rayDirR = rayDirection * particleRotation;
    const vec3 grdu    = giscl * rayDirR;
    const vec3 grd     = safe_normalize(grdu);

	const vec3 gcrod = SURFEL_PRIMITIVE ? gro + grd * -gro.z / grd.z : cross(grd, gro);
	const float grayDist = dot(gcrod, gcrod);

	const float gres = particleResponse(grayDist);
	const float galpha = min(0.99f, gres * particleDensity);

	const bool acceptHit = (gres > minParticleKernelDensity) && (galpha > minParticleAlpha);

	if (acceptHit) {
        const float weight = galpha * (transmittance);

		const vec3 grds = particleScale * grd * (SURFEL_PRIMITIVE ? -gro.z / grd.z : dot(grd, -1 * gro));
		const float hitT = sqrt(dot(grds, grds));

		vec3 sphCoefficients[SPH_MAX_NUM_COEFFS];
		fetchParticleSphCoefficients(
			particleIdx,
//#if BUFFER_REFERENCE
//			sphCoefficientBufferDeviceAddress,
//#endif
			sphCoefficients);
		const vec3 grad = radianceFromSpH(sphEvalDegree, sphCoefficients, rayDirection, true);

		radiance += grad * weight;
		transmittance *= (1 - galpha);
		depth += hitT * weight;

//#if ENABLE_NORMALS
//		const float ellispoidSqRadius = 9.0f;
//		const vec3 particleScaleRotated = (particleRotation * particleScale);
//		normal += weight * (SURFEL_PRIMITIVE ? vec3(0, 0, (grd.z > 0 ? 1 : -1) * particleScaleRotated.z) : safe_normalize((gro + grd * (dot(grd, -1 * gro) - sqrt(ellispoidSqRadius - grayDist))) * particleScaleRotated));
//#endif
	}

	return acceptHit;
}

void main()
{
	// set ray origin, direction
	const vec2 inUV = vec2(gl_GlobalInvocationID.xy) / vec2(windowSizeX, windowSizeY);
	vec2 d = inUV * 2.0f - 1.0f;	// pixel position in NDC

	vec4 rayOrigin = uboDynamic.viewInverse[3];
	vec4 target = uboDynamic.projInverse * vec4(d.x, d.y, 1.0f, 1.0f) ;	// (pixel position in EC) / Wc
	vec4 rayDirection = normalize(uboDynamic.viewInverse * vec4(target.xyz, 0.0f));

	/*** 3dgrt style ***/
	vec3 rayRadiance = vec3(0.0f);
	float rayTransmittance = 1.0f;
	float rayHitDistance = 0.0f;

#ifdef ENABLE_NORMALS
	vec3 rayNormal = vec3(0.0f);
#endif
#ifdef ENABLE_HIT_COUNTS
	uint rayHitsCount = 0;
#endif

	vec2 minMaxT = intersectAABB(uboStatic.aabb, rayOrigin.xyz, rayDirection.xyz);
	const float epsT = EPS_T;

	float rayLastHitDistance = max(0.0f, minMaxT.x - epsT);

	while((rayLastHitDistance <= minMaxT.y) && (rayTransmittance > uboStatic.minTransmittance)){
		// Gather k hits
		rayQueryEXT rayQuery;
		trace(rayQuery, rayOrigin.xyz, rayDirection.xyz, rayLastHitDistance + epsT, minMaxT.y + epsT);

		if(rayPayload.hits[0].particleId == INVALID_PARTICLE_ID){
			break;
		}

		// Process k hits
        for(int i = 0; i < MAX_HIT_PER_TRACE; i++){
			const RayHit rayHit = rayPayload.hits[nonuniformEXT(i)];

			if((rayHit.particleId != INVALID_PARTICLE_ID) && (rayTransmittance > uboStatic.minTransmittance)){
				const bool acceptedHit = processHit(
					rayOrigin.xyz,
					rayDirection.xyz,
					rayHit.particleId,
#if BUFFER_REFERENCE
					uboStatic.densityBufferDeviceAddress,
					uboStatic.sphCoefficientBufferDeviceAddress,
					uboStatic.visibilityBufferDeviceAddress,
#endif
					uboStatic.hitMinGaussianResponse,
					ALPHA_MIN_THRESHOLD,
					uboStatic.sphEvalDegree,
					rayTransmittance,
					rayRadiance,
					rayHitDistance
#if ENABLE_NORMALS
					,rayNormal
#endif
				);

				rayLastHitDistance = max(rayLastHitDistance, rayHit.dist);

#ifdef ENABLE_HIT_COUNTS
				rayHitsCount += acceptedHit ? 1 : 0;
#endif
			}
		}
	}

    imageStore(image, ivec2(gl_GlobalInvocationID.xy), vec4(rayRadiance, 1.0f));
}