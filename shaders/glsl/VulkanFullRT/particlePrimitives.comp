/*
 * Abura Soba, 2025
 * 
 * Full Ray Tracing
 *
 * Compute shader
 */

 #version 460
///////////////////////////////////////////////
#define MOGRenderAdaptiveKernelClamping 1 << 0
///////////////////////////////////////////////

#include "../base/3dgs.glsl"

layout (local_size_x = NUM_OF_GAUSSIANS) in;

layout(std140, binding = 0) buffer Vertices
{
	vec3 gPrimVrt[];
};
layout(std140, binding = 1) buffer Triangles
{
	ivec3 gPrimTri[];
};
layout(std140, binding = 2) buffer Position
{
	vec3 gPos[];
};
layout(std140, binding = 3) buffer Rotation
{
	vec4 gRot[];
};
layout(std140, binding = 4) buffer Scale
{
	vec3 gScl[];
};
layout(std140, binding = 5) buffer Density
{
	float gDns[];
};
layout (binding = 6) uniform UBO 
{
	uint gNum;
	float kernelMinResponse;
	uint opts;
	float degree;
} ubo;
///////////////////////////////////////////////
const uint icosaHedronNumVrt = 12;
const uint icosaHedronNumTri = 20;

const float goldenRatio   = 1.618033988749895;
const float icosaEdge     = 1.323169076499215;
const float icosaVrtScale = 0.5 * icosaEdge;
///////////////////////////////////////////////
float kernelScale(float density, float modulatedMinResponse, uint opts, float kernelDegree) {
    const float responseModulation = (opts & MOGRenderAdaptiveKernelClamping) != 0 ? density : 1.0f;
    const float minResponse = min(modulatedMinResponse / responseModulation, 0.97f);

    // bump kernel
    if (kernelDegree < 0) {
        const float k  = abs(kernelDegree);
        const float s  = 1.0 / pow(3.0, k);
        const float ks = pow((1.f / (log(minResponse) - 1.f) + 1.f) / s, 1.f / k);
        return ks;
    }

    // linear kernel
    if (kernelDegree == 0) {
        return ((1.0f - minResponse) / 3.0f) / -0.329630334487f;
    }

    /// generalized gaussian of degree b : scaling a = -4.5/3^b
    /// e^{a*|x|^b}
    const float b = kernelDegree;
    const float a = -4.5f / pow(3.0f, b);
    /// find distance r (>0) st e^{a*r^b} = minResponse
    /// TODO : reshuffle the math to call powf only once
    return pow(log(minResponse) / a, 1.0f / b);
}

void quaternionWXYZToMatrix(const vec4 q, inout mat3 ret) {
    const float r = q.x;
    const float x = q.y;
    const float y = q.z;
    const float z = q.w;

    // Compute rotation matrix from quaternion
	ret[0] = vec3((1.0f - 2.0f * (y * y + z * z)), 2.0f * (x * y + r * z), 2.0f * (x * z - r * y));
    ret[1] = vec3(2.0f * (x * y - r * z), (1.0f - 2.0f * (x * x + z * z)), 2.0f * (y * z + r * x));
    ret[2] = vec3(2.0f * (x * z + r * y), 2.0f * (y * z - r * x), (1.f - 2.0f * (x * x + y * y)));
}
///////////////////////////////////////////////
void main()
{	
    const uint idx = gl_GlobalInvocationID.x;
    if (idx < ubo.gNum) {
        const uint sVertIdx = icosaHedronNumVrt * idx;
        const uint sTriIdx  = icosaHedronNumTri * idx;

        mat3 rot;
        quaternionWXYZToMatrix(gRot[idx], rot);
        const vec3 scl = gScl[idx];
        const vec3 trans = gPos[idx];

        const vec3 icosaHedronVrt[icosaHedronNumVrt] = {
			vec3(-1, goldenRatio, 0), vec3(1, goldenRatio, 0), vec3(0, 1, -goldenRatio),
            vec3(-goldenRatio, 0, -1), vec3(-goldenRatio, 0, 1), vec3(0, 1, goldenRatio),
            vec3(goldenRatio, 0, 1), vec3(0, -1, goldenRatio), vec3(-1, -goldenRatio, 0),
            vec3(0, -1, -goldenRatio), vec3(goldenRatio, 0, -1), vec3(1, -goldenRatio, 0)
		};

        const vec3 kscl = kernelScale(gDns[idx], ubo.kernelMinResponse, ubo.opts, ubo.degree) * scl * icosaVrtScale;
#pragma unroll
        for (int i = 0; i < icosaHedronNumVrt; ++i) {
            gPrimVrt[sVertIdx + i] = (icosaHedronVrt[i] * kscl) * rot + trans;
        }

        const ivec3 icosaHedronTri[icosaHedronNumTri] = {
            ivec3(0, 1, 2), ivec3(0, 2, 3), ivec3(0, 3, 4), ivec3(0, 4, 5), ivec3(0, 5, 1),
            ivec3(6, 1, 5), ivec3(6, 5, 7), ivec3(6, 7, 11), ivec3(6, 11, 10), ivec3(6, 10, 1),
            ivec3(8, 4, 3), ivec3(8, 3, 9), ivec3(8, 9, 11), ivec3(8, 11, 7), ivec3(8, 7, 4),
            ivec3(9, 3, 2), ivec3(9, 2, 10), ivec3(9, 10, 11),
            ivec3(5, 4, 7), ivec3(1, 10, 2)
		};

        const ivec3 triIdxOffset = ivec3(sVertIdx, sVertIdx, sVertIdx);

#pragma unroll
        for (int i = 0; i < icosaHedronNumTri; ++i) {
            gPrimTri[sTriIdx + i] = icosaHedronTri[i] + triIdxOffset;
        }
    }
}
